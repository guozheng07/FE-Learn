# 1 学习资料
- [hello-网页版](https://www.hello-algo.com/)
- [hello-pdf版](https://github.com/user-attachments/files/16831580/hello-algo-1.1.0-zh-javascript.pdf)
- [hello-code](https://github.com/krahets/hello-algo)

# 2 学习路线
- 阶段一：算法入门。我们需要熟悉各种数据结构的特点和用法，学习不同算法的原理、流程、用途和效 率等方面的内容。
- 阶段二：刷算法题。建议从热门题目开刷，先积累至少 100 道题目，熟悉主流的算法问题。初次刷题 时，“知识遗忘”可能是一个挑战，但请放心，这是很正常的。我们可以按照“艾宾浩斯遗忘曲线”来 复习题目，通常在进行 3~5 轮的重复后，就能将其牢记在心。推荐的题单和刷题计划请见https://github.com/krahets/LeetCode-Book。
- 阶段三：搭建知识体系。在学习方面，我们可以阅读算法专栏文章、解题框架和算法教材，以不断丰富 知识体系。在刷题方面，可以尝试采用进阶刷题策略，如按专题分类、一题多解、一解多题等，相关的 刷题心得可以在各个社区找到。

![image](https://github.com/user-attachments/assets/f6db3c05-208b-4b4a-a01e-4b11b4d28227)

# 3 算法定义
算法(algorithm)是在有限时间内解决特定问题的一组指令或操作步骤，它具有以下特性。
- **问题是明确的**，包含清晰的输入和输出定义。
- **具有可行性**，能够在有限步骤、时间和内存空间下完成。
- **各步骤都有确定的含义**，在相同的输入和运行条件下，输出始终相同。

数据结构与算法高度相关、紧密结合，具体表现在以下三个方面。
- **数据结构是算法的基石**。数据结构为算法提供了结构化存储的数据，以及操作数据的方法。
- **算法是数据结构发挥作用的舞台**。数据结构本身仅存储数据信息，结合算法才能解决特定问题。
- **算法通常可以基于不同的数据结构实现**，但执行效率可能相差很大，**选择合适的数据结构是关键**。

可以将数据结构与算法类比为拼装积木，积木代表数据，积木的形状和连接方式等代表数据结构，拼装积木的步骤则对应算法。

# 4 算法复杂度
## 4.1 迭代与递归
迭代(iteration)是一种重复执行某个任务的控制结构。在迭代中，程序会在满足一定的条件下**重复执行某段代码**，直到这个条件不再满足。**适用于简单循环任务**，例如 for 循环和 while 循环。

递归(recursion)是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。 
1. **递**：程序不断深入地**调用自身**，通常传入更小或更简化的参数，直到达到“终止条件”。
2. **归**：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。

而从实现的角度看，**递归代码主要包含三个要素（判断是否可用递归实现）**。
1. **终止条件**：用于决定什么时候由“递”转“归”。
2. **递归调用**：对应“递”，函数调用自身，**通常输入更小或更简化的参数**。
3. **返回结果**：对应“归”，**将当前递归层级的结果返回至上一层**。

迭代与递归的区别：
1. 代表了两种完全不同的思考和解决问题的范式
   - 迭代：**“自下而上”地解决问题**。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。
   - 递归：**“自上而下”地解决问题**。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止(基本情况的解是已知的)。

**选择迭代还是递归取决于特定问题的性质**。

### 4.1.1 递归的劣势：耗费调用栈空间
**递归函数每次调用自身时，系统都会为新开启的函数分配内存**，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果：
- 函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，**递归通常比迭代更加耗费内存空间**。**过深的递归可能导致栈溢出错误**。
- 递归调用函数会产生额外的开销。因此**递归通常比循环的时间效率更低**。

### 4.1.2 递归的优化：尾递归
**如果函数在返回前的最后一步才进行递归调用**，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为**尾递归**(tail recursion)。
- 普通递归：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。
- 尾递归：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。

以计算 1 + 2 + ⋯ + 𝑛 为例，可以**将结果变量 res 设为函数参数，从而实现尾递归**：
```
/* 普通递归 */
function recur(n) {
   // 终止条件
   if (n === 1) return 1;
   // 递：递归调用
   const res = recur(n - 1);
   // 归：返回结果
   return n + res;
}
```
```
/* 尾递归 */
function tailRecur(n, res) {
   // 终止条件
   if (n === 0) return res;
   // 尾递归调用（只执行了一次tailRecur）
   return tailRecur(n - 1, res + n);
}
```
![image](https://github.com/user-attachments/assets/28827d58-3847-430f-8ebe-86cd31563d72)

![image](https://github.com/user-attachments/assets/8c96456b-531c-4897-93e9-4f6c0d1e58b5)

对比普通递归和尾递归，两者的求和操作的执行点是不同的：
- 普通递归：**求和操作是在“归”的过程中执行的**，每层返回后都要再执行一次求和操作。
- 尾递归：**求和操作是在“递”的过程中执行的**，“归”的过程只需层层返回。

注意：**许多编译器、解释器（例如某些浏览器）并不支持尾递归优化**。例如，Python 默认不支持尾递归优化，**因此即使函数是尾递归形式，仍然可能会遇到栈溢出问题**。

### 4.1.3 递归树
给定一个斐波那契数列 0, 1, 1, 2, 3, 5, 8, 13, ... ，求该数列的第 𝑛 个数字。

设斐波那契数列的第 𝑛 个数字为 𝑓(𝑛) ，易得两个结论。
- 数列的前两个数字为𝑓(1)=0和𝑓(2)=1。
- 数列中的每个数字是前两个数字的和，即 𝑓(𝑛) = 𝑓(𝑛 − 1) + 𝑓(𝑛 − 2) 。

```
/* 斐波那契数列：递归 */
function fib(n) {
   // 终止条件 f(1)=0，f(2)=1
   if (n===1 || n===2) return n-1;
   // 递归调用 f(n) = f(n-1) + f(n-2)
   const res = fib(n-1) + fib(n-2);
   // 返回结果 f(n)
   return res;
}
```

![image](https://github.com/user-attachments/assets/c1ca2e6d-0400-4d5c-82ef-9ef7863b416d)

**从本质上看，递归体现了“将问题分解为更小子问题”的思维范式**，这种分治策略至关重要。
- 从算法角度看，搜索、排序、回溯、分治、动态规划等许多重要算法策略直接或间接地应用了这种思维方式。
- 从数据结构角度看，**递归天然适合处理链表、树和图的相关问题**，因为它们非常适合用分治思想进行分析。

## 4.2 时间复杂度
### 4.2.1 统计时间增长趋势
**时间复杂度分析统计的不是算法运行时间，而是算法运行时间随着数据量变大时的增长趋势**。

### 4.2.2 函数渐近上界
```
function algorithm(n) {
   var a = 1; // +1
   a += 1; // +1
   a *= 2; // +1
   // 循环 n 次
   for(let i = 0; i < n; i++){ // +1(每轮都执行 i ++)
        console.log(0); // +1
   }
}
```
设算法的操作数量是一个关于输入数据大小 𝑛 的函数，记为 𝑇 (𝑛) ，则以上函数的操作数量为: 𝑇 (𝑛) = 3 + 2𝑛（每次循环中都执行i ++和打印）。

𝑇 (𝑛) 是一次函数，说明其运行时间的增长趋势是线性的，因此它的时间复杂度是线性阶，我们将线性阶的时间复杂度记为 𝑂(𝑛) 。

若存在正实数𝑐和实数𝑛0 ，使得对于所有的𝑛>𝑛0 ，均有𝑇(𝑛)≤𝑐⋅𝑓(𝑛)，则可认为𝑓(𝑛)给 出了 𝑇 (𝑛) 的一个渐近上界，记为 𝑇 (𝑛) = 𝑂(𝑓 (𝑛)) 。

### 4.2.3 推算方法
1. **第一步：统计操作数量**
![image](https://github.com/user-attachments/assets/e1d4751c-f302-4c91-8ef2-ea636a0d7b44)

2. **判断渐近上界**

### 4.2.4 常见类型
