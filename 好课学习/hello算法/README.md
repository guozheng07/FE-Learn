1. 学习资料
- [hello-网页版](https://www.hello-algo.com/)
- [hello-pdf版](https://github.com/user-attachments/files/16831580/hello-algo-1.1.0-zh-javascript.pdf)
- [hello-code](https://github.com/krahets/hello-algo)

2. 学习路线
- 阶段一：算法入门。我们需要熟悉各种数据结构的特点和用法，学习不同算法的原理、流程、用途和效 率等方面的内容。
- 阶段二：刷算法题。建议从热门题目开刷，先积累至少 100 道题目，熟悉主流的算法问题。初次刷题 时，“知识遗忘”可能是一个挑战，但请放心，这是很正常的。我们可以按照“艾宾浩斯遗忘曲线”来 复习题目，通常在进行 3~5 轮的重复后，就能将其牢记在心。推荐的题单和刷题计划请见https://github.com/krahets/LeetCode-Book。
- 阶段三：搭建知识体系。在学习方面，我们可以阅读算法专栏文章、解题框架和算法教材，以不断丰富 知识体系。在刷题方面，可以尝试采用进阶刷题策略，如按专题分类、一题多解、一解多题等，相关的 刷题心得可以在各个社区找到。

![image](https://github.com/user-attachments/assets/f6db3c05-208b-4b4a-a01e-4b11b4d28227)

3. 算法定义
算法(algorithm)是在有限时间内解决特定问题的一组指令或操作步骤，它具有以下特性。
- **问题是明确的**，包含清晰的输入和输出定义。
- **具有可行性**，能够在有限步骤、时间和内存空间下完成。
- **各步骤都有确定的含义**，在相同的输入和运行条件下，输出始终相同。

数据结构与算法高度相关、紧密结合，具体表现在以下三个方面。
- **数据结构是算法的基石**。数据结构为算法提供了结构化存储的数据，以及操作数据的方法。
- **算法是数据结构发挥作用的舞台**。数据结构本身仅存储数据信息，结合算法才能解决特定问题。
- **算法通常可以基于不同的数据结构实现**，但执行效率可能相差很大，**选择合适的数据结构是关键**。

可以将数据结构与算法类比为拼装积木，积木代表数据，积木的形状和连接方式等代表数据结构，拼装积木的步骤则对应算法。

4. 算法复杂度
# 4.1 迭代与递归
迭代(iteration)是一种重复执行某个任务的控制结构。在迭代中，程序会在满足一定的条件下**重复执行某段代码**，直到这个条件不再满足。例如 for 循环和 while 循环。

递归(recursion)是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。 
1. **递**：程序不断深入地**调用自身**，通常传入更小或更简化的参数，直到达到“终止条件”。
2. **归**：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。

而从实现的角度看，**递归代码主要包含三个要素（判断是否可用递归实现）**。
1. **终止条件**：用于决定什么时候由“递”转“归”。
2. **递归调用**：对应“递”，函数调用自身，**通常输入更小或更简化的参数**。
3. **返回结果**：对应“归”，**将当前递归层级的结果返回至上一层**。

迭代与递归的区别：
1. 代表了两种完全不同的思考和解决问题的范式
   - 迭代：**“自下而上”地解决问题**。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。
   - 递归：**“自上而下”地解决问题**。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止(基本情况的解是已知的)。

# 4.2 递归的劣势：耗费调用栈空间
**递归函数每次调用自身时，系统都会为新开启的函数分配内存**，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果：
- 函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，**递归通常比迭代更加耗费内存空间**。**过深的递归可能导致栈溢出错误**。
- 递归调用函数会产生额外的开销。因此**递归通常比循环的时间效率更低**。

# 4.3 递归的优化：尾递归
**如果函数在返回前的最后一步才进行递归调用**，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为**尾递归**(tail recursion)。
- 普通递归：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。
- 尾递归：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。

以计算 1 + 2 + ⋯ + 𝑛 为例，可以**将结果变量 res 设为函数参数，从而实现尾递归**：
```
/* 普通递归 */
function recur(n) {
   // 终止条件
   if (n === 1) return 1;
   // 递：递归调用
   const res = recur(n - 1);
   // 归：返回结果
   return n + res;
}
```
```
/* 尾递归 */
function tailRecur(n, res) {
   // 终止条件
   if (n === 0) return res;
   // 尾递归调用
   return tailRecur(n - 1, res + n);
}
```
