# 概览
Fetch、Axios、Ajax 和XHR都是前端用于发送HTTP请求的工具或技术：

Fetch：一种现代化的网络请求方法，通过使用 Promise 处理异步操作，简洁而直观地发送HTTP请求、处理响应，并支持各种功能和API，如设置请求头、传递参数、处理流数据、上传下载文件等。

Axios：一个基于Promise的现代化HTTP客户端，是目前最流行的 HTTP 客户端，可以在浏览器和Node.js环境中发送HTTP请求，并具有拦截请求和响应、支持并发请求、提供丰富的API等功能。

Ajax：通过在浏览器和服务器之间进行异步通信，实现部分页面更新和动态交互，提升用户体验；可以在不重新加载整个页面的情况下，通过JavaScript发送HTTP请求到服务器，并处理服务器返回的数据；减少带宽消耗，提高页面加载速度；提高用户交互性，实现更多的动态效果和实时更新。

XHR：一种在浏览器中用于与服务器进行异步通信的API，通过发送HTTP请求并处理服务器返回的数据，实现异步获取各种格式的数据（如XML、JSON、HTML等），以实现页面的无刷新更新和动态交互。

下面就来看看这些技术都是怎么用的，以及都有什么特点！

# XHR
XMLHttpRequest 是一个内置的 JavaScript 对象，XMLHttpRequest（XHR）对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。

XMLHttpRequest 在 AJAX 编程中被大量使用。尽管名称包含XML，XMLHttpRequest 也可以用于获取任何类型的数据，而不仅仅是 XML。它甚至支持 HTTP 以外的协议（包括 file:// 和 FTP）。

XMLHttpRequest 存在一些缺点：
- **语法复杂性**：使用原始的 XMLHttpRequest 进行复杂的 AJAX 请求需要编写更多的代码，并手动处理状态管理、错误处理等方面的逻辑。相比之下，Axios 和 Fetch API 提供了更简单和直观的语法，使得发送和处理 HTTP 请求更加方便。
- **功能限制**：XHR 提供的功能相对较少，需要手动设置请求头、处理超时、取消请求等。而 Axios 和 Fetch API 提供了更丰富的功能，如拦截请求和响应、自动转换数据格式、请求取消等。
- **XSRF（跨站请求伪造）保护**：在 Axios 中，可以通过设置 **withCredentials** 选项来自动处理 XSRF 保护。然而，在 XMLHttpRequest 和 Fetch API 中，需要手动设置请求头来实现类似的保护。
- **错误处理**：XHR 的错误处理较为繁琐，需要在回调函数中进行错误判断。而 Axios 和 Fetch API 使用 Promise 和 async/await 语法，能够更便捷地处理请求和响应的错误。
- **仅限于浏览器环境**：XMLHttpRequest 是浏览器提供的 API，因此只能在浏览器环境中使用，无法在其他环境中（如服务器端）直接使用。

## 请求步骤
使用 XMLHttpRequest 发送请求的步骤如下：
```
// 1.创建XMLHttpRequest对象
let xhr = new XMLHttpRequest();
// 2.设置请求参数
xhr.open('GET', 'https://example.com/api/data', true);
// 3.设置请求头（可选）
xhr.setRequestHeader('Content-Type', 'application/json');
// 4.监听状态变化
xhr.onreadystatechange = () => {
  if (xhr.readyState === 4) {
    if (xhr.status === 200) {
      // 请求成功，处理响应
      console.log(xhr.responseText);
    } else {
      // 请求失败
      console.error('请求失败');
    }
  }
};
// 5.发送请求
xhr.send();
```
这里创建了一个**XMLHttpRequest对象**，并使用**open()方法**设置了一个GET请求类型和URL。然后，通过监听**onreadystatechange事件**来判断请求的状态并处理响应。当**readyState**为4时，表示请求已完成，此时可以通过**status**属性判断请求是否成功（200表示成功）。如果成功，可以通过**responseText**属性获取服务器返回的数据进行处理。如果失败，将到控制台输出错误信息。

## open方法
XMLHttpRequest 的 open() 方法用于初始化一个请求。open() 方法接受三个必填参数和两个可选参数，它们是：
```
// 1.method: 表示请求的 HTTP 方法，例如 GET、POST、PUT 等。
// 2.url: 表示请求的 URL 地址。
// 3.async: 表示请求是否异步执行，即是否使用异步模式。默认为 true，表示异步执行；false 表示同步执行。
// 4.username (可选): 表示用于进行 HTTP 认证的用户名。
// 5.password (可选): 表示用于进行 HTTP 认证的密码。
xhr.open(method, url, async, username, password);
```

## 请求头和响应头
可以使用 **setRequestHeader() 方法设置 XMLHttpRequest 的请求头**。这个方法接受两个参数：头字段的名称和值。
```
xhr.setRequestHeader("Content-Type", "application/json");
xhr.setRequestHeader("Authorization", "Bearer token123");
```
这里使用 setRequestHeader() 方法设置了两个请求头：Content-Type 和 Authorization。第一个参数是头字段的名称，第二个参数是头字段的值。

可以使用 **getResponseHeader() 方法或者 getAllResponseHeaders() 方法来获取 XMLHttpRequest 的响应头**。
```
// 1.getResponseHeader()：通过指定头字段的名称，可以获取指定的响应头字段的值。
const contentType = xhr.getResponseHeader("Content-Type"); // 使用 getResponseHeader() 方法获取了名为 Content-Type的响应头字段的值。

// 2.getAllResponseHeaders()：该方法返回一个包含所有响应头信息的字符串。
const headers = xhr.getAllResponseHeaders(); // 使用 getAllResponseHeaders() 方法获取了所有响应头信息，并将其存储在名为 headers 的变量中。
```
这里返回的 headers 是一个包含所有响应头信息的字符串。该字符串中每一行表示一个响应头字段。例如，如果响应头中包含 Content-Type 和 Authorization 字段，那么返回的 headers 字符串可能如下所示：
```
Content-Type: application/json
Authorization: Bearer token123
```
可以使用适当的方法（如字符串解析）将这个字符串进行进一步处理，以获取特定的响应头字段的名称和值。

注意，**要在调用 open() 方法之后、发送请求之前使用 setRequestHeader() 方法来设置请求头，以确保设置能够生效。** 同样，**要在接收到响应之后才能使用 getResponseHeader() 或 getAllResponseHeaders() 来获取响应头信息。**

## readyState
上面示例中的 readyState 是 XMLHttpRequest 对象的一个属性，用于表示请求的状态。该属性有以下五种可能的取值：
- 0 (未初始化): XMLHttpRequest 对象已创建，但尚未调用 open 方法。
- 1 (载入中): open 方法已调用，但尚未调用 send 方法。
- 2 (载入完成): send 方法已调用，并且响应头和响应状态已经可用。
- 3 (交互中): 正在接收响应数据，此时部分响应内容可能已经可以访问了。
- 4 (完成): 响应数据接收完成，整个请求过程已经完全结束。

通常情况下，我们主要关注 readyState 为 4 的状态，即请求完成状态。在这个状态下，我们可以通过检查 status 属性来获取请求的结果（比如响应状态码），并通过 responseText 或 responseXML 属性来获取服务器返回的数据。

注意，**readyState 属性是只读的，我们不能直接修改它的值。它会在请求过程中自动更新，我们可以通过监听 readystatechange 事件来进行相应的处理。**

## status
status 是 XMLHttpRequest 对象的一个属性，用于表示 HTTP 状态码。 HTTP 状态码是服务器对请求处理的结果进行响应的标准化数字代码。常见的一些 HTTP 状态码包括：
- 200 OK：表示请求成功并返回所请求的数据。
- 201 Created：表示请求成功并在服务器上创建了新资源。
- 204 No Content：表示请求成功，但响应中无返回的内容。
- 400 Bad Request：表示请求有语法错误或参数错误，服务器无法理解。
- 401 Unauthorized：表示请求未经授权，需要用户进行身份验证。
- 403 Forbidden：表示服务器拒绝请求，通常是因为请求的资源没有访问权限。
- 404 Not Found：表示请求的资源不存在。
- 500 Internal Server Error：表示服务器内部发生错误，无法完成请求。

在使用 XMLHttpRequest 发送请求后，可以通过检查 status 属性来获取服务器对请求的响应状态码，并根据不同的状态码进行相应的处理。

## 事件属性
XMLHttpRequest (XHR) 对象具有以下常用的事件属性：

1. onreadystatechange: 当 readyState 属性发生变化时触发该事件。可以使用 xhr.onreadystatechange 属性来指定处理状态变化的回调函数。在每次状态变化时都会触发该事件，可以通过检查 xhr.readyState 属性来确定当前的状态。
```
xhr.onreadystatechange = () => {
  if(xhr.readyState === 4) {
    // 请求已完成
    if(xhr.status === 200) {
      // 请求成功
    } else {
      // 请求失败
    }
  } else {
    // 请求进行中
  }
};
```
2. onload: 当请求成功完成并且响应数据完全加载时触发该事件。可以使用 xhr.onload 属性来指定处理成功加载的回调函数。通常在这个事件中获取和处理响应数据。
```
xhr.onload = () => {
  // 获取和处理响应数据
  const responseData = JSON.parse(xhr.responseText);
  // 其他操作...
};
```
3. onerror: 当请求发生错误时触发该事件。可以使用 xhr.onerror 属性来指定处理错误的回调函数。常见的错误包括网络错误、无法完成请求等。
```
xhr.onerror = () => {
  // 处理错误逻辑
};
```
4. onprogress: 在数据传输过程中持续触发，用于追踪请求的进度。可以使用 xhr.onprogress 属性来指定处理进度的回调函数。
```
xhr.onprogress = (event) => {
  // 处理进度逻辑
};
```
5. ontimeout： 当请求超时时触发该事件。可以使用 xhr.ontimeout 属性来指定处理超时的回调函数。
```
xhr.ontimeout = () => {
  // 处理超时逻辑
};
```

## responseType 
responseType 是 XMLHttpRequest 对象的属性，用于指定响应的数据类型。它决定了如何解析从服务器返回的响应数据。 常见的 responseType 值包括：
1. "" (默认值): 表示响应的数据类型是字符串。
```
xhr.responseType = "";
```
2. "text": 表示响应的数据类型是字符串。
```
xhr.responseType = "text";
```
3. "json": 表示响应的数据类型是 JSON 对象，会自动将响应数据解析为 JavaScript 对象。
```
xhr.responseType = "json";
```
4. "document": 表示响应的数据类型是 XML 文档对象，会自动将响应数据解析为 XML 文档对象。
```
xhr.responseType = "document";
```
5. "arraybuffer": 表示响应的数据类型是 ArrayBuffer 对象，适用于二进制数据的传输和处理。
```
xhr.responseType = "arraybuffer";
```
6. "blob": 表示响应的数据类型是 Blob 对象，适用于文件下载等场景。
```
xhr.responseType = "blob";
```
通过设置不同的 responseType 值，可以根据需要获取不同类型的响应数据。注意，**在设置 responseType 之前，最好在调用 open 方法之后、发送请求之前设置，以确保设置生效。**

# Ajax
AJAX（Asynchronous JavaScript and XML，异步 JavaScript 和 XML）是一种使用现有的网页技术来创建异步请求和更新页面内容的方法。Ajax 本身不是一种技术，而是一种将一些现有技术结合起来使用的方法，包括：HTML 或 XHTML、CSS、JavaScript、DOM、XML、XSLT、以及最重要的 XMLHttpRequest 对象。

当使用结合了这些技术的 Ajax 模型以后，网页应用能够快速地将增量更新呈现在用户界面上，而不需要重载（刷新）整个页面。这使得程序能够更快地回应用户的操作。**Ajax 最吸引人的特性是它的“异步”性质，这意味着它可以与服务器通信、交换数据并更新页面，而无需刷新页面。**

Ajax 是一种使用浏览器提供的 XMLHttpRequest 对象实现的技术，用于在不刷新整个页面的情况下进行异步请求和更新页面内容。**可以说 Ajax 是基于浏览器提供的 XMLHttpRequest 对象来实现的。**

以下是基于原生 JavaScript 的 AJAX 请求代码示例：
```
// 创建 XMLHttpRequest 对象
const xhr = new XMLHttpRequest();

// 指定请求的方法和 URL
xhr.open('GET', 'api_url', true);  // 第三个参数 true 表示异步请求

// 设置请求头（如果需要）
xhr.setRequestHeader('Content-Type', 'application/json');  // 根据实际需求设置请求头

// 注册一个回调函数来处理响应
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4 && xhr.status === 200) {
    const response = JSON.parse(xhr.responseText);  // 处理响应数据
    // 在这里执行相应的操作
    console.log(response);
  }
};

// 发送请求
xhr.send();
```
虽然 AJAX 是一种强大的技术，但相对于 Axios 和 Fetch API，它有以下一些缺点：
- **兼容性问题**：AJAX 的兼容性相对较低，尤其在旧版本的浏览器中可能会出现问题。而 Axios 和 Fetch API 使用了更现代的 JavaScript 特性，具有更好的兼容性。
- **代码冗余**：使用原生的 AJAX 需要编写较多的代码来处理不同的状态码、错误处理以及请求的拼装等。而 Axios 和 Fetch API 提供了更简洁和易用的接口，减少了代码冗余。
- **缺乏默认配置**：AJAX 不提供默认的全局配置，如请求和响应拦截器、统一的错误处理等。而 Axios 和 Fetch API 支持全局配置，并且提供了更方便的拦截器机制。
- **功能限制**：AJAX 在处理跨域请求时需要注意添加额外的处理，比如设置 CORS 头部信息或者使用 JSONP。而 Axios 和 Fetch API 提供了更直接的方式来处理跨域请求。
- **可读性较差**：由于 AJAX 使用的是回调函数来处理异步请求，可能会导致代码逻辑比较复杂，可读性较差。而 Axios 和 Fetch API 使用的是 Promise 或 async/await，使代码结构更加清晰易读。

# Fetch
Fetch 是一种用于进行网络请求的现代 JavaScript API。它提供了一种简单、灵活且功能强大的方式，用于从服务器获取资源并处理响应。

Fetch API 在浏览器中原生支持，并且以 Promise 为基础，使得异步请求更加直观和易用。使用 Fetch API，可以执行各种类型的请求（如 GET、POST、PUT、DELETE 等），发送请求时可以设置请求头、请求参数，以及处理响应数据。

与传统的 AJAX 相比，Fetch API 具有以下优点：
- **Promise 支持**：Fetch API 使用 Promise 对象来处理异步操作，使得处理异步请求的流程更加清晰、易于阅读和编写。
- **更简洁的 API**：Fetch API 提供了一个简洁的 API，使发送请求变得更加直观和简单，同时提供了丰富的配置选项（如设置请求头、请求参数等）。
- **内置的 JSON 解析**：在处理响应时，Fetch API 内置了对 JSON 数据的解析，无需手动调用JSON.parse进行解析操作。
- **更好的错误处理**：Fetch API 使用了更全面的错误处理机制，允许通过检查响应状态码来确定请求是否成功，并以不同的方式处理错误。

## fetch方法
Fetch API 提供了一个全局的 fetch() 方法，该方法提供了一种简单、逻辑的方式来通过网络异步获取资源。

fetch() 方法的语法如下：
```
fetch(url, options)
  .then(response => {
    // 在这里处理响应
  })
  .catch(error => {
    // 在这里处理错误
  });

```
