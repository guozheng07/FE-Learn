# 11 | this：从JavaScript执行上下文的视角讲清楚this
## 1 JavaScript中的this是什么
**this是和执行上下文绑定的**。执行上下文有全局执行上下文、函数执行上下文和eval执行上下文，所以对应的this也只有全局执行上下文中的this、函数中的this和eval中的this（使用不多，不做介绍）。

**作用域链和this是两套不同的系统，它们之间基本没太多联系**。

## 2 全局执行上下文中的this
**全局执行上下文中的this是指向window对象的。这也是this和作用域链的唯一交点，作用域链的最底端包含了window对象，全局执行上下文中的this也是指向window对象**。

## 3 函数执行上下文中的this
### 3.1 通过函数的call方法设置
```
let bar = {
  myName : "极客邦",
  test1 : 1
}
function foo(){
  this.myName = "极客时间"
}
foo.call(bar)
console.log(bar) // {myName: '极客时间', test1: 1}
console.log(myName) // Uncaught ReferenceError: myName is not defined
```
上述代码中，**通过函数的call方法来设置函数执行上下文的this指向**，foo函数内部的this已经指向了bar对象，因为通过打印bar对象，可以看出bar的myName属性已经由“极客邦”变为“极客时间”了。同时在全局执行上下文中打印myName，JavaScript引擎提示该变量未定义。

**除了call方法，你还可以使用bind和apply方法来设置函数执行上下文中的this。**

### 3.2 通过对象调用方法设置
```
var myObj = {
  name : "极客时间", 
  showThis: function(){
    console.log(this)
  }
}
myObj.showThis() // 可以认为是myObj.showThis.call(myObj)
```
![image](https://github.com/user-attachments/assets/5982201c-4f5d-47ab-9192-fce261900f0b)

上述代码中，定义了一个myObj对象，该对象是由一个name属性和一个showThis方法组成的，然后再通过myObj对象来调用showThis方法。执行这段代码，你可以看到，最终输出的this值是指向myObj的。

**使用对象来调用其内部的一个方法，该方法的this是指向对象本身的。**

```
var myObj = {
  name : "极客时间",
  showThis: function(){
    this.name = "极客邦"
    console.log(this)
  }
}
var foo = myObj.showThis
foo()
```
![image](https://github.com/user-attachments/assets/510811d7-ff69-4b19-a825-f2e9090a84a4)

上述代码中，把showThis赋给一个全局对象，然后再调用该对象，发现this又指向了全局window对象。

结论：
- **在全局环境中调用一个函数，函数内部的this指向的是全局变量window。**
- **通过一个对象来调用其内部的一个方法，该方法的执行上下文中的this指向对象本身。**

### 3.3 通过构造函数中设置
```
function CreateObj(){
  this.name = "极客时间"
}
var myObj = new CreateObj()
```
上述代码中，使用new创建了对象myObj，**构造函数中的this其实就是新对象本身。**

当执行new CreateObj()的时候，JavaScript引擎做了如下四件事：
- 首先创建了一个空对象tempObj；
- 接着调用CreateObj.call方法，并将tempObj作为call方法的参数，这样当CreateObj的执行上下文创建时，它的this就指向了tempObj对象；
- 然后执行CreateObj函数，此时的CreateObj函数执行上下文中的this指向了tempObj对象；
- 最后返回tempObj对象。

## 4 this的设计缺陷以及应对方案
### 4.1 嵌套函数中的this不会从外层函数中继承
```
var myObj = {
  name : "极客时间", 
  showThis: function(){
    console.log(this)
    function bar(){console.log(this)}
    bar()
  }
}
myObj.showThis()
```
![image](https://github.com/user-attachments/assets/38112636-608b-44e0-a62d-4cac6e67db10)

上述代码中，函数bar中的this指向的是全局window对象，而函数showThis中的this指向的是myObj对象。这就是JavaScript中非常容易让人迷惑的地方之一，也是很多问题的源头。

```
// 将函数bar中的this指向myObj对象
  showThis: function(){
    console.log(this)
    var self = this
    function bar(){
      self.name = "极客邦"
    }
    bar()
  }
}
myObj.showThis()
console.log(myObj.name)
console.log(window.name) // 为什么也输出了"极客邦"？
```
![image](https://github.com/user-attachments/assets/7ce5abae-37cf-447f-8373-386744002623)

在showThis函数中声明一个变量self用来保存this，然后在bar函数中使用self，**这个方法的的本质是把this体系转换为了作用域的体系。**

```
// 将函数bar中的this指向myObj对象
var myObj = {
  name : "极客时间", 
  showThis: function(){
    console.log(this)
    var bar = () => {
      this.name = "极客邦"
      console.log(this)
    }
    bar()
  }
}
myObj.showThis()
console.log(myObj.name)
console.log(window.name) // 为什么也输出了"极客邦"？
```
![image](https://github.com/user-attachments/assets/634452a1-24e0-47ed-ae14-e0a63e7ee08e)

**ES6中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的this取决于它的外部函数。**

总结：**this没有作用域的限制，这点和变量不一样，所以嵌套函数不会从调用它的函数中继承this，这样会造成很多不符合直觉的代码**。要解决这个问题，你可以有两种思路：
- 第一种是把this保存为一个self变量，再利用变量的作用域机制传递给嵌套函数。
- 第二种是继续使用this，但是要把嵌套函数改为箭头函数，因为箭头函数没有自己的执行上下文，所以它会继承调用函数中的this。

### 4.2 普通函数中的this默认指向全局对象window
通过4.1中代码可知，在默认情况下调用一个函数，其执行上下文中的this是默认指向全局对象window的。

不过这个设计也是一种缺陷，因为在实际工作中，我们并不希望函数执行上下文中的this默认指向全局对象，因为这样会打破数据的边界，造成一些误操作。如果要让函数执行上下文中的this指向某个对象，最好的方式是通过call方法来显示调用。

这个问题可以通过设置JavaScript的“严格模式”来解决。**在严格模式下，默认执行一个函数，其函数的执行上下文中的this值是undefined，这就解决上面的问题了**。

## 5 总结
首先，在使用this时，为了避坑，你要谨记以下三点：
- 当函数作为对象的方法调用时，函数中的this就是该对象；
- 当函数被正常调用时，在严格模式下，this值是undefined，非严格模式下this指向的是全局对象window；
- 嵌套函数中的this不会继承外层函数的this值。

最后，我们还提了一下箭头函数，因为箭头函数没有自己的执行上下文，所以箭头函数的this就是它外层函数的this。



