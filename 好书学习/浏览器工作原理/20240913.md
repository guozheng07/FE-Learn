# 导读
- 什么是回调函数
- 什么是同步回调？什么是异步回调，请用代码解释下
- 请使用浏览器的Performance分析页面加载过程的调用栈信息，其他指标随意发挥
- 请代码实现XMLHttpRequest
- 什么是跨域？跨域有什么影响？平时开发过程中如何解决跨域问题？
- HTTPS混合资源会造成什么问题？
- 什么是宏任务？宏任务是如何工作的？常见的宏任务有哪些？
- 什么是微任务？微任务是怎么工作的？常见的微任务有哪些？

# 17 | WebAPI：XMLHttpRequest是怎么实现的？
## 回调函数 VS 系统调用栈
将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是回调函数。
- 同步回调：回调函数是**在主函数返回之前执行**的回调过程。
- 异步回调：回调函数**在主函数外部执行**的过程。

上节内容回顾：  
浏览器页面是通过事件循环机制来驱动的，每个渲染进程都有一个消息队列，页面主线程按照顺序来执行消息队列中的事件，如执行JavaScript事件、解析DOM事件、计算布局事件、用户输入事件等等，如果页面有新的事件产生，那新的事件将会追加到事件队列的尾部。所以可以说是**消息队列和主线程循环机制保证了页面有条不紊地运行**。

![image](https://github.com/user-attachments/assets/b0b06563-9a3b-4373-9b4e-0ac31dd3bf7d)

每个任务在执行过程中都有自己的调用栈，那么同步回调就是在当前主函数的上下文中执行回调函数。下面我们主要来看看异步回调过程，**异步回调是指回调函数在主函数之外执行，一般有两种方式**：
- **第一种是把异步函数做成一个任务，添加到信息队列尾部**；
- **第二种是把异步函数添加到微任务队列中，这样就可以在当前任务的末尾处执行微任务了**。

## XMLHttpRequest运作机制
![image](https://github.com/user-attachments/assets/fc1c6731-fd8d-44fb-bffa-f735dd530f3c)

```
 function GetWebData(URL){
    /**
     * 1:新建XMLHttpRequest请求对象
     */
    let xhr = new XMLHttpRequest()

    /**
     * 2:注册相关事件回调处理函数 
     */
    xhr.onreadystatechange = function () {
        switch(xhr.readyState){
          case 0: // 客户端已被创建，还未调用 open() 方法
            console.log("请求未初始化")
            break;
          case 1: // 已经调用 open() 方法，正在等待调用 send() 方法
            console.log("OPENED")
            break;
          case 2: // 已经发送请求，并接收到响应头部
            console.log("HEADERS_RECEIVED")
            break;
          case 3: // 请求正在处理中，正在接收到响应体数据
            console.log("LOADING")
            break;
          case 4: // 请求已完成并响应就绪，此时可以使用 responseText 和 responseXML 访问响应内容
            if(this.status == 200||this.status == 304){
                console.log(this.responseText);
                }
            console.log("DONE")
            break;
        }
    }

    xhr.ontimeout = function(e) { console.log('ontimeout') }
    xhr.onerror = function(e) { console.log('onerror') }

    /**
     * 3:打开请求
     */
    xhr.open('Get', URL, true);// 创建一个Get请求,采用异步

    /**
     * 4:配置参数
     */
    xhr.timeout = 3000 // 设置xhr请求的超时时间
    xhr.responseType = "text" // 设置响应返回的数据格式
    xhr.setRequestHeader("X_TEST","time.geekbang")

    /**
     * 5:发送请求
     */
    xhr.send();
}
```

第一步：创建 XMLHttpRequest 对象

![image](https://github.com/user-attachments/assets/23a5da9d-1740-44e5-aea3-a67d7f17786c)

第二步：为 xhr 对象注册回调函数

![image](https://github.com/user-attachments/assets/f83c4807-8c03-402c-a8de-dd834606427e)

第三步：配置基础的请求信息

![image](https://github.com/user-attachments/assets/b78e758e-fa0a-437a-a804-f5927dd9c4c4)

第四步：发起请求

![image](https://github.com/user-attachments/assets/7972088a-c005-488e-aed6-d0fda89763b7)

## XMLHttpRequest 使用过程中的“坑”
在使用 XMLHttpRequest 的过程中，会遇到跨域问题和混合内容问题。

1. 跨域问题
跨域：协议、ip、端口号（ip+端口号是域名）不一致。

例如，www.geekbang.org 和 time.geekbang.com 不属于一个域。打开 time.geekbang.com 网址，打开控制台，输入请求 www.geekbang.org 地址的请求代码，会访问失败。

```
Access to XMLHttpRequest at 'https://time.geekbang.org/' from origin 'https://www.geekbang.org' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
```

该访问就属于跨域访问了，这次访问失败就是由于跨域问题导致的。

2. HTTPS 混合内容的问题
HTTPS 混合内容是 HTTPS 页面中包含了不符合 HTTPS 安全要求的内容，比如包含了 HTTP 资源，通过 HTTP 加载的图像、视频、样式表、脚本等，都属于混合内容。

![image](https://github.com/user-attachments/assets/61cc2b70-859f-4b03-81da-a175cce2917c)

![image](https://github.com/user-attachments/assets/21571097-8565-444f-8f7c-4075806ba8f2)

# 18 | 宏任务和微任务：不是所有任务都是一个待遇
## 回顾
![image](https://github.com/user-attachments/assets/79d32c83-2d45-4a87-bede-e2283dd94363)

## 宏任务
页面中的大部分任务都是在主线程上执行的，这些任务包括了：
- 渲染事件（如解析 DOM、计算布局、绘制）；
- 用户交互事件（如鼠标点击、滚动页面、放大缩小等）；
- JavaScript 脚本执行事件；
- 网络请求完成、文件读写完成事件。

为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个 for 循环，不断地从这些任务队列中取出任务并执行任务。**我们把这些消息队列中的任务称为宏任务**。

宏任务在事件循环中的流程：
- 先从多个消息队列中选出一个最老的任务，这个任务称为 oldestTask；
- 然后循环系统记录任务开始执行的时间，并把这个 oldestTask 设置为当前正在执行的任务；
- 当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个 oldestTask；
- 最后统计执行完成的时长等信息。

以上就是消息队列中宏任务的执行过程。

宏任务可以满足我们大部分的日常需求，不过如果有对时间精度要求较高的需求，宏任务就难以胜任了。

前面我们说过，**页面的渲染事件、各种 IO 的完成事件、执行 JavaScript 脚本的事件、用户交互的事件等都随时有可能被添加到消息队列中，而且添加事件是由系统操作的，JavaScript 代码不能准确掌控任务要添加到队列中的位置，控制不了任务在消息队列中的位置，所以很难控制开始执行任务的时间**。

```
<!DOCTYPE html>
<html>
    <body>
        <div id='demo'>
            <ol>
                <li>test</li>
            </ol>
        </div>
    </body>
    <script type="text/javascript">
        function timerCallback2(){
          console.log(2)
        }
        function timerCallback(){
            console.log(1)
            setTimeout(timerCallback2,0)
        }
        setTimeout(timerCallback,0)
    </script>
</html>
```

在上述代码中，目的是想通过 setTimeout 来设置两个回调任务，并让它们按照前后顺序来执行，中间也不要再插入其他的任务，因为如果这两个任务的中间插入了其他的任务，就很有可能会影响到第二个定时器的执行时间了。但实际情况是我们不能控制的，比如在你调用 setTimeout 来设置回调任务的间隙，消息队列中就有可能被插入很多系统级的任务。你可以打开 Performance 工具，来记录下这段任务的执行过程，也可参考文中记录的图片：

![image](https://github.com/user-attachments/assets/e59222ec-2acc-4055-8b48-82bf6807e38b)

setTimeout 函数触发的回调函数都是宏任务，如图中，左右两个黄色块就是 setTimeout 触发的两个定时器任务。

现在你可以重点观察上图中间浅红色区域，这里有很多一段一段的任务，这些是被渲染引擎插在两个定时器任务中间的任务。试想一下，如果中间被插入的任务执行时间过久的话，那么就会影响到后面任务的执行了。

所以说宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合了，比如后面要介绍的监听 DOM 变化的需求。

## 微任务
在上一篇文章中，我们介绍过异步回调的概念，其主要有两种方式。
- 第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。这种比较好理解，我们前面介绍的 setTimeout 和 XMLHttpRequest 的回调函数都是通过这种方式来实现的。
- 第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。

**微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前**。

```
function executor(resolve, reject) {
    let rand = Math.random();
    console.log(1)
    console.log(rand)
    if (rand > 0.5)
        resolve()
    else
        reject()
}
var p0 = new Promise(executor);

var p1 = p0.then((value) => {
    console.log("succeed-1")
    return new Promise(executor)
})


var p3 = p1.then((value) => {
    console.log("succeed-2")
    return new Promise(executor)
})

var p4 = p3.then((value) => {
    console.log("succeed-3")
    return new Promise(executor)
})


p4.catch((error) => {
    console.log("error")
})
console.log(2)
```
