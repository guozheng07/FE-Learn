# 导读
- 事件循环机制是什么？
- 为什么V8引擎需要事件循环机制？
- 如何设计跨线程之间的消息通信的线程模型？
- 描述浏览器渲染进程与其他进程之间是如何实现通信的？
- 描述所知道的消息队列中的任务类型有哪些？
- 页面线程的循环系统是如何工作的？
- 思考题：结合消息队列和事件循环，你认为微任务是什么？引入微任务能带来什么优势呢？为什么要引入微任务？
- 浏览器怎么实现setTimeout的？
- 在使用定时器setTimeout过程中存在的哪些些陷阱？
- 思考题：解下requestAnimationFrame的工作机制，并对比setTimeout，然后分析出requestAnimationFrame实现的动画效果比setTimeout好的原因。

# 上周todo
- 下面代码为什么会有这样的输出结果？
```
function foo(){
    console.log('foo',this);
}  

foo.call(123); // Number {123}
```
- apply，call具体实现
- 闭包的内存管理
- weakmap如何实现弱引用

# 15 | 消息队列和事件循环：页面是怎么“活”起来的？
## 1 使用单线程处理安排好的任务
```
void MainThread(){
    int num1 = 1+2; // 任务1
    int num2 = 20/5; // 任务2
    int num3 = 7*8; // 任务3
    print("最终计算的值为:%d,%d,%d",num1,num2,num3)； // 任务4
}
```
在上面的执行代码中，我们把所有任务代码按照顺序写进主线程里，等线程执行时，这些任务会按照顺序在线程中依次被执行；等所有任务执行完成之后，线程会自动退出。

## 2 在线程运行过程中处理新任务
但并不是所有的任务都是在执行之前统一安排好的，大部分情况下，新的任务是在线程运行过程中产生的。比如在线程执行过程中，又接收到了一个新的任务要求计算“10+2”，那上面那种方式就无法处理这种情况了。

**要想在线程运行过程中，能接收并执行新的任务，就需要采用事件循环机制。**
```
// GetInput：等待用户从键盘输入一个数字，并返回该输入的数字
int GetInput(){
    int input_number = 0;
    cout<<"请输入一个数:";
    cin>>input_number;
    return input_number;
}

// 主线程(Main Thread)
void MainThread(){
     for(;;){
          int first_num = GetInput()；
          int second_num = GetInput()；
          result_num = first_num + second_num;
          print("最终计算的值为:%d",result_num)；
      }
}
```
相较于第一版的线程，这一版的线程做了两点改进。
- **第一点引入了循环机制**，具体实现方式是在线程语句最后添加了一个**for循环语句**，线程会一直循环执行。
- **第二点是引入了事件**，可以在线程运行过程中，等待用户输入的数字，等待过程中线程处于暂停状态，一旦接收到用户输入的信息，那么线程会被激活，然后执行相加运算，最后输出结果。

通过引入事件循环机制，就可以让该线程“活”起来了，我们每次输入两个数字，都会打印出两数字相加的结果，你可以结合下图来参考下这个改进版的线程：

![image](https://github.com/user-attachments/assets/c0740bb8-c5f3-4ec7-8075-4b903e6fd8f3)

# 3 处理其他线程发送过来的任务
在第二版的线程模型中，所有的任务都是来自于线程内部的，如果另外一个线程想让主线程执行一个任务，利用第二版的线程模型是无法做到的。

下面我们就来看看其他线程是如何发送消息给渲染主线程的，具体形式你可以参考下图：

从上图可以看出，渲染主线程会频繁接收到来自于IO线程的一些任务，接收到这些任务之后，渲染进程就需要着手处理，比如接收到资源加载完成的消息后，渲染进程就要着手进行DOM解析了；接收到鼠标点击的消息后，渲染主线程就要开始执行相应的JavaScript脚本来处理该点击事件。

那么如何设计好一个线程模型，能让其能够接收其他线程发送的消息呢？

一个通用模式是使用消息队列。在解释如何实现之前，我们先说说什么是消息队列，可以参考下图：

![image](https://github.com/user-attachments/assets/0ab78660-8769-43e2-bb25-24cd176909e3)

从上图可以看出，**渲染主线程会频繁接收到来自于IO线程的一些任务，接收到这些任务之后，渲染进程就需要着手处理**，比如接收到资源加载完成的消息后，渲染进程就要着手进行DOM解析了；接收到鼠标点击的消息后，渲染主线程就要开始执行相应的JavaScript脚本来处理该点击事件。

那么**如何设计好一个线程模型，能让其能够接收其他线程发送的消息呢？一个通用模式是使用消息队列**。在解释如何实现之前，我们先说说什么是消息队列，可以参考下图：

![image](https://github.com/user-attachments/assets/0f5da1f1-5803-4719-a276-e42a2f472d9e)

从图中可以看出，**消息队列是一种数据结构，可以存放要执行的任务**。它**符合队列“先进先出”的特点**，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。

有了队列之后，我们就可以继续改造线程模型了，改造方案如下图所示：


从上图可以看出，我们的改造可以分为下面三个步骤：
- 添加一个消息队列；
- IO线程中产生的新任务添加进消息队列尾部；
- 渲染主线程会循环地从消息队列头部中读取任务，执行任务。

有了这些步骤之后，那么接下来我们就可以按步骤使用代码来实现第三版的线程模型：
```
构造一个队列：
class TaskQueue{
  public:
  Task takeTask(); // 取出队列头部的一个任务
  void pushTask(Task task); // 添加一个任务到队列尾部
};
```
```
让主线程从队列中读取任务：
TaskQueue task_queue；
void ProcessTask();
void MainThread(){
  for(;;){
    Task task = task_queue.takeTask();
    ProcessTask(task);
  }
}
```
```
其他线程想要发送任务让主线程去执行，将任务添加到该消息队列中：
Task clickTask;
task_queue.pushTask(clickTask)
```

由于是多个线程操作同一个消息队列，所以在添加任务和取出任务时还会加上一个同步锁。

## 4 处理其他进程发送过来的任务
通过使用消息队列，我们实现了线程之间的消息通信。在Chrome中，跨进程之间的任务也是频繁发生的，那么如何处理其他进程发送过来的任务？你可以参考下图：

![image](https://github.com/user-attachments/assets/e0d55130-c1d2-4a18-bfef-0e158ab9250f)

从图中可以看出，**渲染进程专门有一个IO线程用来接收其他进程传进来的消息**，接收到消息之后，会将这些消息组装成任务发送给渲染主线程，后续的步骤就和前面讲解的“处理其他线程发送的任务”一样了，这里就不再重复了。

## 5 消息队列中的任务类型
消息队列中的任务类型有哪些?
- 包含了很多内部消息类型，如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript定时器等。
- 除此之外，消息队列中还包含了很多与页面相关的事件，如JavaScript执行、解析DOM、样式计算、布局计算、CSS动画等。

以上这些事件都是在主线程中执行的，所以在编写Web应用时，你还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。

## 6 如何安全退出？
当页面主线程执行完成之后，又该如何保证页面主线程能够安全退出呢？Chrome是这样解决的，确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志。

如果设置了，那么就直接中断当前的所有任务，退出线程，你可以参考下面代码：

```
TaskQueue task_queue；
void ProcessTask();
bool keep_running = true;
void MainThread(){
  for(;;){
    Task task = task_queue.takeTask();
    ProcessTask(task);
    if(!keep_running) //如果设置了退出标志，那么直接退出线程循环
        break; 
  }
}
```

## 7 页面使用单线程的缺点
消息队列是“先进先出”的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。鉴于这个属性，就有如下两个问题需要解决。
- **第一个问题是如何处理高优先级的任务**。
![image](https://github.com/user-attachments/assets/4fb46e67-953e-4691-bc4d-1f9130ab73ac)

- **第二个是如何解决单个任务执行时长过久的问题**。
![image](https://github.com/user-attachments/assets/342a1471-ddb7-4e0c-a7db-7866c5b6bea3)

## 8 实践：浏览器页面是如何运行的？
你可以打开开发者工具，点击“Performance”标签，选择左上角的“start porfiling and load page”来记录整个页面加载过程中的事件执行情况，如下图所示：

![image](https://github.com/user-attachments/assets/53e6dc51-6e60-4444-a432-b3dc78f7d600)

从图中可以看出，我们点击展开了Main这个项目，其记录了主线程执行过程中的所有任务。图中灰色的就是一个个任务，每个任务下面还有子任务，其中的Parse HTML任务，是把HTML解析为DOM的任务。值得注意的是，在执行Parse HTML的时候，如果遇到JavaScript脚本，那么会暂停当前的HTML解析而去执行JavaScript脚本。

## 9 总结
- 如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务，这是第一版线程模型。
- 要在线程执行过程中接收并处理新的任务，就需要引入循环语句和事件系统，这是第二版线程模型。
- 如果要接收其他线程发送过来的任务，就需要引入消息队列，这是第三版线程模型。
- 如果其他进程想要发送任务给页面主线程，那么先通过IPC（进程间通信，Inter-Process Communication）把任务发送给渲染进程的IO线程，IO线程再把任务发送给页面主线程。
- 消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务。
- 基于消息队列的设计是目前使用最广的消息架构，无论是安卓还是Chrome都采用了类似的任务机制，所以理解了本篇文章的内容后，你再理解其他项目的任务机制也会比较轻松。

## 10 思考时间
今天给你留的思考题是：结合消息队列和事件循环，你认为微任务是什么？引入微任务能带来什么优势呢？

**微任务**（Microtasks）是现代浏览器和 JavaScript 环境中引入的一种任务调度机制，它们**用来处理一系列高优先级的任务**，这些任务在当前的事件循环（Event Loop）周期内执行，以确保更高的响应性和更好的用户体验。**微任务常用于处理 Promise 的回调函数**。

### 微任务的定义和执行时机
在事件循环中，每次运行一个宏任务（如用户事件、I/O 事件、定时器等）后，都会检查并执行所有的微任务。微任务一般在以下情况下被添加：
1. **Promise 的回调**：Promise 的 `.then` 和 `.catch` 回调会被调度为微任务。
2. **MutationObserver**：用于监听 DOM 变化的 MutationObserver 回调也是微任务。

### 微任务的执行顺序
执行顺序如下：
1. 执行一个宏任务（例如从事件队列取出一个任务）。
2. 检查微任务队列，并执行其中所有的微任务，直到队列为空。
3. 渲染更新（如果有的话）。
4. 重复上述步骤，循环处理。

**示例**

```
console.log('脚本开始');

setTimeout(() => {
  console.log('宏任务 - setTimeout');
}, 0);

Promise.resolve().then(() => {
  console.log('微任务 - Promise');
});

console.log('脚本结束');
```

**输出顺序**：

```
脚本开始
脚本结束
微任务 - Promise
宏任务 - setTimeout
```

在上述例子中，**Promise 回调作为微任务会在脚本同步任务执行完毕后立即执行**，而 setTimeout 回调作为宏任务则等待下一个事件循环周期。

### 引入微任务的优势
1. **提高响应性**：微任务在当前事件循环周期内执行，在用户可见的响应时间内完成，因此能更及时地响应状态更新。
2. **更优的异步代码管理**：微任务使得处理异步操作变得更加容易和高效，特别是在 Promise 的使用场景中，可以确保异步回调的顺序性和可预测性。
3. **减少渲染抖动**：在当前事件循环周期内处理所有微任务，可以减少中间不必要的渲染，优化页面性能。这样可以让 DOM 更新更为集中，减少页面的重排和重绘次数。

### 微任务在实践中的应用
1. **Promise**：如前所示，Promise 的回调函数是以微任务方式执行的。
2. **DOM 变化观察**：MutationObserver利用微任务队列来批量处理 DOM 变动，可以避免用户界面频繁、细粒度的更新。
3. **Polyfill**：手动控制微任务队列有助于一些低版本浏览器的特性兼容。

**示例：使用 `MutationObserver`**：

```
const targetNode = document.getElementById('some-id');
const config = { attributes: true, childList: true, subtree: true };

const callback = function(mutationsList, observer) {
    for(const mutation of mutationsList) {
        if (mutation.type === 'childList') {
            console.log('A child node has been added or removed.');
        }
        else if (mutation.type === 'attributes') {
            console.log('The ' + mutation.attributeName + ' attribute was modified.');
        }
    }
};

const observer = new MutationObserver(callback);
observer.observe(targetNode, config);
```

**总结**：

**微任务**在现代 JavaScript 和浏览器中显得特别重要，因为它们**提供了一种高效的异步处理机制**。**通过微任务，可以在不干扰用户界面和提高性能的基础上，快速有效地处理重要的异步操作**。这不仅有助于提升代码的可维护性，还能显著改善用户体验。

##  tips
在浏览器中，渲染主线程（UI 线程）负责处理多种类型的事件，包括来自 IO（输入/输出）线程的事件，如资源加载完成事件和用户交互事件（如鼠标点击事件）。下面是对这些事件的详细说明：

![image](https://github.com/user-attachments/assets/6c417c87-af14-4d9f-9053-b509bf48eba6)

![image](https://github.com/user-attachments/assets/3a0a163a-44c0-45c6-bd70-353b5bca1bc0)

**在多线程编程中，当多个线程需要访问或修改同一个共享资源（如消息队列）时，需要使用同步机制来避免竞态条件（Race Condition），保证数据的一致性和线程安全**。常见的同步机制包括互斥锁（Mutex）、读写锁（Read-Write Lock）、条件变量（Condition Variable）等。

以下是使用 C++ 标准库中的 std::mutex 和 std::condition_variable 来实现一个线程安全的消息队列的示例：
```
#include <iostream>
#include <queue>
#include <thread>
#include <mutex>
#include <condition_variable>

template<typename T>
class ThreadSafeQueue {
public:
    // 添加任务
    void enqueue(T item) {
        std::unique_lock<std::mutex> lock(mtx);
        q.push(std::move(item));
        cv.notify_one(); // 通知一个等待的线程
    }

    // 取出任务
    T dequeue() {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [this]() { return !q.empty(); }); // 等待队列非空
        T item = std::move(q.front());
        q.pop();
        return item;
    }
    
    // 检查队列是否为空
    bool empty() {
        std::unique_lock<std::mutex> lock(mtx);
        return q.empty();
    }

private:
    std::queue<T> q;
    std::mutex mtx;
    std::condition_variable cv;
};

void producer(ThreadSafeQueue<int>& queue) {
    for (int i = 0; i < 10; ++i) {
        std::cout << "Producing: " << i << std::endl;
        queue.enqueue(i);
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}

void consumer(ThreadSafeQueue<int>& queue) {
    for (int i = 0; i < 10; ++i) {
        int item = queue.dequeue();
        std::cout << "Consuming: " << item << std::endl;
    }
}

int main() {
    ThreadSafeQueue<int> queue;
    
    std::thread prod_thread(producer, std::ref(queue));
    std::thread cons_thread(consumer, std::ref(queue));

    prod_thread.join();
    cons_thread.join();

    return 0;
}
```
![image](https://github.com/user-attachments/assets/341c68cd-cc31-4c09-bf4f-866d8cbc2a3d)

# 16 | WebAPI：setTimeout是如何实现的？
