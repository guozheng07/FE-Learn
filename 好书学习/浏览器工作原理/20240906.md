# 导读
- 事件循环机制是什么？
- 为什么V8引擎需要事件循环机制？
- 如何设计跨线程之间的消息通信的线程模型？
- 描述浏览器渲染进程与其他进程之间是如何实现通信的？
- 描述所知道的消息队列中的任务类型有哪些？
- 页面线程的循环系统是如何工作的？
- 思考题：结合消息队列和事件循环，你认为微任务是什么？引入微任务能带来什么优势呢？为什么要引入微任务？
- 浏览器怎么实现setTimeout的？
- 在使用定时器setTimeout过程中存在的哪些些陷阱？
- 思考题：解下requestAnimationFrame的工作机制，并对比setTimeout，然后分析出requestAnimationFrame实现的动画效果比setTimeout好的原因。

# 上周todo
- 下面代码为什么会有这样的输出结果？
```
function foo(){
    console.log('foo',this);
}  

foo.call(123); // Number {123}
```
- apply，call具体实现
- 闭包的内存管理
- weakmap如何实现弱引用

# 15 | 消息队列和事件循环：页面是怎么“活”起来的？
## 使用单线程处理安排好的任务
```
void MainThread(){
    int num1 = 1+2; // 任务1
    int num2 = 20/5; // 任务2
    int num3 = 7*8; // 任务3
    print("最终计算的值为:%d,%d,%d",num1,num2,num3)； // 任务4
}
```
在上面的执行代码中，我们把所有任务代码按照顺序写进主线程里，等线程执行时，这些任务会按照顺序在线程中依次被执行；等所有任务执行完成之后，线程会自动退出。

## 在线程运行过程中处理新任务
但并不是所有的任务都是在执行之前统一安排好的，大部分情况下，新的任务是在线程运行过程中产生的。
```
// GetInput：等待用户从键盘输入一个数字，并返回该输入的数字
int GetInput(){
    int input_number = 0;
    cout<<"请输入一个数:";
    cin>>input_number;
    return input_number;
}

// 主线程(Main Thread)
void MainThread(){
     for(;;){
          int first_num = GetInput()；
          int second_num = GetInput()；
          result_num = first_num + second_num;
          print("最终计算的值为:%d",result_num)；
      }
}
```
相较于第一版的线程，这一版的线程做了两点改进。
- 第一点引入了循环机制，具体实现方式是在线程语句最后添加了一个for循环语句，线程会一直循环执行。
- 第二点是引入了事件，可以在线程运行过程中，等待用户输入的数字，等待过程中线程处于暂停状态，一旦接收到用户输入的信息，那么线程会被激活，然后执行相加运算，最后输出结果。

通过引入事件循环机制，就可以让该线程“活”起来了，我们每次输入两个数字，都会打印出两数字相加的结果，你可以结合下图来参考下这个改进版的线程：
# 16 | WebAPI：setTimeout是如何实现的？
