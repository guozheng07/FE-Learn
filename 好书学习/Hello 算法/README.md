# 1 学习资料
- [hello-网页版](https://www.hello-algo.com/)
- [hello-pdf版](https://github.com/user-attachments/files/16831580/hello-algo-1.1.0-zh-javascript.pdf)
- [hello-code](https://github.com/krahets/hello-algo)

# 2 学习路线
- 阶段一：算法入门。我们需要熟悉各种数据结构的特点和用法，学习不同算法的原理、流程、用途和效 率等方面的内容。
- 阶段二：刷算法题。建议从热门题目开刷，先积累至少 100 道题目，熟悉主流的算法问题。初次刷题 时，“知识遗忘”可能是一个挑战，但请放心，这是很正常的。我们可以按照“艾宾浩斯遗忘曲线”来 复习题目，通常在进行 3~5 轮的重复后，就能将其牢记在心。推荐的题单和刷题计划请见https://github.com/krahets/LeetCode-Book。
- 阶段三：搭建知识体系。在学习方面，我们可以阅读算法专栏文章、解题框架和算法教材，以不断丰富 知识体系。在刷题方面，可以尝试采用进阶刷题策略，如按专题分类、一题多解、一解多题等，相关的 刷题心得可以在各个社区找到。

![image](https://github.com/user-attachments/assets/f6db3c05-208b-4b4a-a01e-4b11b4d28227)

# 3 算法定义
算法(algorithm)是在有限时间内解决特定问题的一组指令或操作步骤，它具有以下特性。
- **问题是明确的**，包含清晰的输入和输出定义。
- **具有可行性**，能够在有限步骤、时间和内存空间下完成。
- **各步骤都有确定的含义**，在相同的输入和运行条件下，输出始终相同。

数据结构与算法高度相关、紧密结合，具体表现在以下三个方面。
- **数据结构是算法的基石**。数据结构为算法提供了结构化存储的数据，以及操作数据的方法。
- **算法是数据结构发挥作用的舞台**。数据结构本身仅存储数据信息，结合算法才能解决特定问题。
- **算法通常可以基于不同的数据结构实现**，但执行效率可能相差很大，**选择合适的数据结构是关键**。

可以将数据结构与算法类比为拼装积木，积木代表数据，积木的形状和连接方式等代表数据结构，拼装积木的步骤则对应算法。

# 4 算法复杂度
## 4.1 迭代与递归
迭代(iteration)是一种重复执行某个任务的控制结构。在迭代中，程序会在满足一定的条件下**重复执行某段代码**，直到这个条件不再满足。**适用于简单循环任务**，例如 for 循环和 while 循环。

递归(recursion)是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。 
1. **递**：程序不断深入地**调用自身**，通常传入更小或更简化的参数，直到达到“终止条件”。
2. **归**：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。

而从实现的角度看，**递归代码主要包含三个要素（判断是否可用递归实现）**。
1. **终止条件**：用于决定什么时候由“递”转“归”。
2. **递归调用**：对应“递”，函数调用自身，**通常输入更小或更简化的参数**。
3. **返回结果**：对应“归”，**将当前递归层级的结果返回至上一层**。

迭代与递归的区别：
1. 代表了两种完全不同的思考和解决问题的范式
   - 迭代：**“自下而上”地解决问题**。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。
   - 递归：**“自上而下”地解决问题**。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止(基本情况的解是已知的)。

**选择迭代还是递归取决于特定问题的性质**。

### 4.1.1 递归的劣势：耗费调用栈空间
**递归函数每次调用自身时，系统都会为新开启的函数分配内存**，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果：
- 函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，**递归通常比迭代更加耗费内存空间**。**过深的递归可能导致栈溢出错误**。
- 递归调用函数会产生额外的开销。因此**递归通常比循环的时间效率更低**。

### 4.1.2 递归的优化：尾递归
**如果函数在返回前的最后一步才进行递归调用**，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为**尾递归**(tail recursion)。
- 普通递归：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。
- 尾递归：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。

以计算 1 + 2 + ⋯ + 𝑛 为例，可以**将结果变量 res 设为函数参数，从而实现尾递归**：
```
/* 普通递归 */
function recur(n) {
   // 终止条件
   if (n === 1) return 1;
   // 递：递归调用
   const res = recur(n - 1);
   // 归：返回结果
   return n + res;
}
```
```
/* 尾递归 */
function tailRecur(n, res) {
   // 终止条件
   if (n === 0) return res;
   return tailRecur(n - 1, res + n);
}
```
![image](https://github.com/user-attachments/assets/28827d58-3847-430f-8ebe-86cd31563d72)

![image](https://github.com/user-attachments/assets/8c96456b-531c-4897-93e9-4f6c0d1e58b5)

对比普通递归和尾递归，两者的求和操作的执行点是不同的：
- 普通递归：**求和操作是在“归”的过程中执行的**，每层返回后都要再执行一次求和操作。
- 尾递归：**求和操作是在“递”的过程中执行的**，“归”的过程只需层层返回。

注意：**许多编译器、解释器（例如某些浏览器）并不支持尾递归优化**。例如，Python 默认不支持尾递归优化，**因此即使函数是尾递归形式，仍然可能会遇到栈溢出问题**。

### 4.1.3 递归树
给定一个斐波那契数列 0, 1, 1, 2, 3, 5, 8, 13, ... ，求该数列的第 𝑛 个数字。

设斐波那契数列的第 𝑛 个数字为 𝑓(𝑛) ，易得两个结论。
- 数列的前两个数字为𝑓(1)=0和𝑓(2)=1。
- 数列中的每个数字是前两个数字的和，即 𝑓(𝑛) = 𝑓(𝑛 − 1) + 𝑓(𝑛 − 2) 。

```
/* 斐波那契数列：递归 */
function fib(n) {
   // 终止条件 f(1)=0，f(2)=1
   if (n===1 || n===2) return n-1;
   // 递归调用 f(n) = f(n-1) + f(n-2)
   const res = fib(n-1) + fib(n-2);
   // 返回结果 f(n)
   return res;
}
```

![image](https://github.com/user-attachments/assets/c1ca2e6d-0400-4d5c-82ef-9ef7863b416d)

**从本质上看，递归体现了“将问题分解为更小子问题”的思维范式**，这种分治策略至关重要。
- 从算法角度看，搜索、排序、回溯、分治、动态规划等许多重要算法策略直接或间接地应用了这种思维方式。
- 从数据结构角度看，**递归天然适合处理链表、树和图的相关问题**，因为它们非常适合用分治思想进行分析。

## 4.2 时间复杂度
### 4.2.1 统计时间增长趋势
**时间复杂度分析统计的不是算法运行时间，而是算法运行时间随着数据量变大时的增长趋势**。

### 4.2.2 函数渐近上界
```
function algorithm(n) {
   var a = 1; // +1
   a += 1; // +1
   a *= 2; // +1
   // 循环 n 次
   for(let i = 0; i < n; i++){ // +1(每轮都执行 i ++)
        console.log(0); // +1
   }
}
```
设算法的操作数量是一个关于输入数据大小 𝑛 的函数，记为 𝑇 (𝑛) ，则以上函数的操作数量为: 𝑇 (𝑛) = 3 + 2𝑛（每次循环中都执行i ++和打印）。

𝑇 (𝑛) 是一次函数，说明其运行时间的增长趋势是线性的，因此它的时间复杂度是线性阶，我们将线性阶的时间复杂度记为 𝑂(𝑛) 。

**若存在正实数𝑐和实数𝑛0 ，使得对于所有的𝑛>𝑛0 ，均有𝑇(𝑛)≤𝑐⋅𝑓(𝑛)，则可认为𝑓(𝑛)给 出了 𝑇 (𝑛) 的一个渐近上界**，记为 𝑇 (𝑛) = 𝑂(𝑓 (𝑛)) 。

### 4.2.3 推算方法
1. **第一步：统计操作数量**
![image](https://github.com/user-attachments/assets/e1d4751c-f302-4c91-8ef2-ea636a0d7b44)

```
function algorithm(n) {
   let a = 1; // +0(技巧 1)
   a = a + n; // +0(技巧 1)
   // +n(技巧 2)
   for(let i = 0; i < 5 * n + 1; i++) {
      console.log(0);
   }
   // +n*n(技巧 3)
   for(let i = 0;i < 2 * n; i++) {
      for(let j = 0; j < n + 1; j++) {
         console.log(0);
      }
   }
}
```
![image](https://github.com/user-attachments/assets/ac7cdae6-751a-4e2b-88cd-b5463ab2cd48)

2. **判断渐近上界**
**时间复杂度由 𝑇 (𝑛) 中最高阶的项来决定**。这是因为在 𝑛 趋于无穷大时，最高阶的项将发挥主导作用，其他 项的影响都可以忽略。

### 4.2.4 常见类型
![image](https://github.com/user-attachments/assets/b0afeac6-a561-4811-9da7-2146d8f7352c)

![image](https://github.com/user-attachments/assets/49120252-98fc-4b39-9c8e-c442887191cb)

1. 常数阶 𝑂(1)
常数阶的操作数量与输入数据大小 𝑛 无关，即不随着 𝑛 的变化而变化。

2. 线性阶 𝑂(𝑛)
线性阶的操作数量相对于输入数据大小 𝑛 以线性级别增长。**线性阶通常出现在单层循环中**。

遍历数组和遍历链表等操作的时间复杂度均为 𝑂(𝑛) ，其中 𝑛 为数组或链表的长度。

3. 平方阶 𝑂(𝑛2)
平方阶的操作数量相对于输入数据大小 𝑛 以平方级别增长。**平方阶通常出现在嵌套循环中，外层循环和内层循环的时间复杂度都为 𝑂(𝑛)** ，因此总体的时间复杂度为 𝑂(𝑛2) 。

![image](https://github.com/user-attachments/assets/b2ceb141-0905-4c45-acc9-b6091d6224b0)

4. 指数阶 𝑂(2^𝑛)
生物学的“细胞分裂”是指数阶增长的典型例子:初始状态为 1 个细胞，分裂一轮后变为 2 个，分裂两轮后变为 4 个，以此类推，分裂 𝑛 轮后有 2𝑛 个细胞。

![image](https://github.com/user-attachments/assets/7b32cbf1-a3b4-44bf-a885-d9f831a58280)

在实际算法中，**指数阶常出现于递归函数中**。例如在以下代码中，其递归地一分为二，经过 𝑛 次分裂后停止：
```
// === File: time_complexity.js ===
/* 指数阶(递归实现) */
function expRecur(n) {
    if (n === 1) return 1;
    return expRecur(n - 1) + expRecur(n - 1) + 1;
}
```

**指数阶**增长非常迅速，**在穷举法(暴力搜索、回溯等)中比较常见**。**对于数据规模较大的问题**，指数阶是不可接受的，**通常需要使用动态规划或贪心算法等来解决**。

5. 对数阶 𝑂(log 𝑛)
与指数阶相反，对数阶反映了“每轮缩减到一半”的情况。设输入数据大小为 𝑛 ，由于每轮缩减到一半，因此循环次数是 log2 𝑛 ，即 2𝑛 的反函数。

![image](https://github.com/user-attachments/assets/8cb88bb7-7785-48e2-b6f3-6f7f40c40a61)

与指数阶类似，**对数阶也常出现于递归函数中**。以下代码形成了一棵高度为 log2 𝑛 的递归树：
```
// === File: time_complexity.js ===
/* 对数阶(递归实现) */
function logRecur(n) {
    if (n <= 1) return 0;
    return logRecur(n / 2) + 1;
}
```

**对数阶常出现于基于分治策略的算法中，体现了“一分为多”和“化繁为简”的算法思想**。它增长缓慢，是仅次于常数阶的理想的时间复杂度。

![image](https://github.com/user-attachments/assets/73f321ec-c200-4920-b5e9-039c739b9877)

6. 线性对数阶 𝑂(𝑛 log 𝑛)
**线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为 𝑂(log 𝑛) 和 𝑂(𝑛)** 。

**主流排序算法的时间复杂度通常为 𝑂(𝑛 log 𝑛) ，例如快速排序、归并排序、堆排序等**。

7. 阶乘阶 𝑂(𝑛!)
阶乘阶对应数学上的“全排列”问题。阶乘通常使用递归实现。

![image](https://github.com/user-attachments/assets/84b8b274-4b6a-4fdf-915b-2ed5c64361c3)

### 4.2.5 最差、最佳、平均时间复杂度
![image](https://github.com/user-attachments/assets/0bd97f0e-aa12-4fce-8493-73dc40c190db)

![image](https://github.com/user-attachments/assets/af8cbab5-35d6-49f8-97be-de29afc66940)

## 4.3 空间复杂度
空间复杂度(space complexity)用于**衡量算法占用内存空间随着数据量变大时的增长趋势**。

### 4.3.1 算法相关空间
算法在运行过程中使用的内存空间主要包括以下几种。
- **输入空间**：用于存储算法的输入数据。
- **暂存空间**：用于存储算法在运行过程中的变量、对象、函数上下文等数据。
- **输出空间**：用于存储算法的输出数据。

一般情况下，空间复杂度的统计范围是“暂存空间”加上“输出空间”。 **暂存空间可以进一步划分**为三个部分。
- **暂存数据**：用于保存算法运行过程中的各种常量、变量、对象等。
- **栈帧空间**：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放。
- **指令空间**：用于保存编译后的程序指令，在实际统计中通常忽略不计。

在分析一段程序的空间复杂度时，**我们通常统计暂存数据、栈帧空间和输出数据三部分**。

### 4.3.2 推算方法
与时间复杂度不同的是，**我们通常只关注最差空间复杂度**。这是因为内存空间是一项硬性要求，我们必须确保在所有输入数据下都有足够的内存空间预留。

观察以下代码，最差空间复杂度中的“最差”有两层含义。
1. **以最差输入数据为准**：当 𝑛 < 10 时，空间复杂度为 𝑂(1) ;但当 𝑛 > 10 时，初始化的数组 nums 占 用 𝑂(𝑛) 空间，因此最差空间复杂度为 𝑂(𝑛) 。
2. **以算法运行中的峰值内存为准**：例如，程序在执行最后一行之前，占用𝑂(1)空间;当初始化数组nums 时，程序占用 𝑂(𝑛) 空间，因此最差空间复杂度为 𝑂(𝑛) 。

![image](https://github.com/user-attachments/assets/8a506924-3281-4727-a6e6-2493cc2f7969)

**在递归函数中，需要注意统计栈帧空间**。
```
function constFunc() {
   // 执行某些操作
   return 0;
}
/* 循环的空间复杂度为 O(1) */
function loop(n) {
   for(let i = 0; i < n; i++) {
      constFunc();
   }
}
/* 递归的空间复杂度为 O(n) */
function recur(n) {
    if (n === 1) return;
    return recur(n - 1);
}
```

函数 loop() 和 recur() 的时间复杂度都为 𝑂(𝑛) ，但空间复杂度不同。
- 函数 loop() 在循环中调用了 𝑛 次 function()，每轮中的 function() 都返回并释放了栈帧空间，因此空间复杂度仍为 𝑂(1) 。
- 递归函数 recur() 在运行过程中会同时存在 𝑛 个未返回的 recur()，从而占用 𝑂(𝑛) 的栈帧空间。

### 4.3.3 常见类型
![image](https://github.com/user-attachments/assets/c45ad066-61cd-440f-9290-c25949f93bd7)

1. 常数阶 𝑂(1)
常数阶常见于数量与输入数据大小 𝑛 无关的常量、变量、对象。

需要注意的是，**在循环中初始化变量或调用函数而占用的内存，在进入下一循环后就会被释放，因此不会累积占用空间，空间复杂度仍为 𝑂(1)** 。

2. 线性阶 𝑂(𝑛)
**线性阶常见于元素数量与 𝑛 成正比的数组、链表、栈、队列等**。
```
// === File: space_complexity.js ===
/* 线性阶 */
function linear(n) {
   // 长度为 n 的数组占用 O(n) 空间
   const nums = new Array(n);
   // 长度为 n 的列表占用 O(n) 空间
   const nodes = [];
   for(let i = 0; i < n; i++){
        nodes.push(new ListNode(i));
    }
   // 长度为 n 的哈希表占用 O(n) 空间
   const map = new Map();
   for(let i = 0; i < n; i++){
        map.set(i, i.toString());
    }
}
```

![image](https://github.com/user-attachments/assets/c57b8814-edde-4581-9899-52a878d8d147)

3. 平方阶 𝑂(𝑛^2)
**平方阶常见于矩阵和图，元素数量与 𝑛 成平方关系**。
```
// === File: space_complexity.js ===

/* 平方阶(递归实现) */
function quadratic(n) {
    // 矩阵占用 O(n^2) 空间
    const numMatrix = Array(n)
        .fill(null)
        .map(() => Array(n).fill(null));
    // 二维列表占用 O(n^2) 空间
    const numList = [];
    for (let i = 0; i < n; i++) {
        const tmp = [];
        for (let j = 0; j < n; j++) {
            tmp.push(0);
        }
        numList.push(tmp);
    }
}
```

![image](https://github.com/user-attachments/assets/7bf0a094-b6f1-4b6e-adf8-d81121074087)

4. 指数阶 𝑂(2𝑛)
**指数阶常见于二叉树**。
```
// === File: space_complexity.js ===

/* 指数阶(建立满二叉树) */
function buildTree(n) {
    if (n === 0) return null;
    const root = new TreeNode(0);
    root.left = buildTree(n - 1);
    root.right = buildTree(n - 1);
    return root;
}
```

![image](https://github.com/user-attachments/assets/6a3ca9f4-8b39-4d8f-bb42-67ada0df5af2)

5. 对数阶 𝑂(log 𝑛)
![image](https://github.com/user-attachments/assets/37c72a2d-818b-4586-8e99-313ccad4a4b6)

### 4.3.4 权衡时间与空间
**降低时间复杂度通常需要以提升空间复杂度为代价，反之亦然**。我们将牺牲内存空间来提升算法运行速度的 思路称为“以空间换时间”;反之，则称为“以时间换空间”。

选择哪种思路取决于我们更看重哪个方面。**在大多数情况下，时间比空间更宝贵，因此“以空间换时间”通 常是更常用的策略**。当然，**在数据量很大的情况下，控制空间复杂度也非常重要**。
